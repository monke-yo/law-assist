"use client";

import React, { useState, useCallback, useMemo } from "react";
import {
  ReactFlow,
  Node,
  Edge,
  Background,
  Controls,
  useNodesState,
  useEdgesState,
  Position,
  BaseEdge,
  getSmoothStepPath,
  EdgeProps,
} from "@xyflow/react";
import "@xyflow/react/dist/style.css";
import { useLanguage, Language } from "@/contexts/LanguageContext";

// Custom animated edge component
function AnimatedEdge({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourcePosition,
  targetPosition,
}: EdgeProps) {
  const [edgePath] = getSmoothStepPath({
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
  });

  return (
    <>
      <BaseEdge id={id} path={edgePath} />
      <circle r="4" fill="#3b82f6" className="animate-pulse">
        <animateMotion dur="3s" repeatCount="indefinite" path={edgePath} />
      </circle>
    </>
  );
}

// Custom node component with checkbox
function WorkflowNode({ data }: { data: any }) {
  const [isCompleted, setIsCompleted] = useState(data.completed || false);

  const handleToggle = () => {
    setIsCompleted(!isCompleted);
    if (data.onToggle) {
      data.onToggle(data.id, !isCompleted);
    }
  };

  return (
    <div
      className={`px-4 py-3 shadow-lg rounded-lg border-2 transition-all duration-300 ${
        isCompleted
          ? "bg-green-100 border-green-500 text-green-800"
          : "bg-white border-gray-300 text-gray-800"
      }`}
    >
      <div className="flex items-center space-x-2">
        <input
          type="checkbox"
          checked={isCompleted}
          onChange={handleToggle}
          className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
        />
        <div>
          <div className="font-semibold text-sm">{data.title}</div>
          <div className="text-xs opacity-75">{data.description}</div>
        </div>
      </div>
      {isCompleted && (
        <div className="mt-2 text-xs text-green-600">
          тЬУ {data.completedText}
        </div>
      )}
    </div>
  );
}

// Multilingual translations
const translations = {
  en: {
    progress: "Progress",
    completed: "Completed",
    helpText:
      "ЁЯТб Click the checkboxes to mark steps as completed. The animated dots show the flow progression.",
    workflows: {
      general: {
        title: "General Legal Process",
        steps: [
          { title: "Initial Consultation", description: "Meet with attorney" },
          { title: "Case Assessment", description: "Evaluate legal options" },
          {
            title: "Document Preparation",
            description: "Gather required documents",
          },
          {
            title: "Filing/Submission",
            description: "Submit to court/authority",
          },
          { title: "Resolution", description: "Complete legal process" },
        ],
      },
      divorce: {
        title: "Divorce Process",
        steps: [
          { title: "File Petition", description: "Submit divorce papers" },
          { title: "Serve Spouse", description: "Legal notification" },
          { title: "Response Period", description: "Wait for spouse response" },
          {
            title: "Discovery/Negotiation",
            description: "Asset division discussion",
          },
          { title: "Final Decree", description: "Court approval" },
        ],
      },
      contract: {
        title: "Contract Dispute Process",
        steps: [
          { title: "Review Contract", description: "Analyze terms & breach" },
          {
            title: "Demand Letter",
            description: "Formal notice to other party",
          },
          { title: "Mediation", description: "Attempt to resolve" },
          { title: "Litigation", description: "File lawsuit if needed" },
          { title: "Judgment/Settlement", description: "Final resolution" },
        ],
      },
    },
  },
  hi: {
    progress: "рдкреНрд░рдЧрддрд┐",
    completed: "рдкреВрд░реНрдг",
    helpText:
      "ЁЯТб рдЪрд░рдгреЛрдВ рдХреЛ рдкреВрд░реНрдг рдХреЗ рд░реВрдк рдореЗрдВ рдЪрд┐рд╣реНрдирд┐рдд рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдЪреЗрдХрдмреЙрдХреНрд╕ рдкрд░ рдХреНрд▓рд┐рдХ рдХрд░реЗрдВред рдПрдирд┐рдореЗрдЯреЗрдб рдбреЙрдЯреНрд╕ рдкреНрд░рд╡рд╛рд╣ рдХреА рдкреНрд░рдЧрддрд┐ рджрд┐рдЦрд╛рддреЗ рд╣реИрдВред",
    workflows: {
      general: {
        title: "рд╕рд╛рдорд╛рдиреНрдп рдХрд╛рдиреВрдиреА рдкреНрд░рдХреНрд░рд┐рдпрд╛",
        steps: [
          { title: "рдкреНрд░рд╛рд░рдВрднрд┐рдХ рдкрд░рд╛рдорд░реНрд╢", description: "рд╡рдХреАрд▓ рд╕реЗ рдорд┐рд▓реЗрдВ" },
          {
            title: "рдХреЗрд╕ рдореВрд▓реНрдпрд╛рдВрдХрди",
            description: "рдХрд╛рдиреВрдиреА рд╡рд┐рдХрд▓реНрдкреЛрдВ рдХрд╛ рдореВрд▓реНрдпрд╛рдВрдХрди рдХрд░реЗрдВ",
          },
          {
            title: "рджрд╕реНрддрд╛рд╡реЗрдЬрд╝ рддреИрдпрд╛рд░реА",
            description: "рдЖрд╡рд╢реНрдпрдХ рджрд╕реНрддрд╛рд╡реЗрдЬрд╝ рдПрдХрддреНрд░ рдХрд░реЗрдВ",
          },
          {
            title: "рдлрд╝рд╛рдЗрд▓рд┐рдВрдЧ/рд╕рдмрдорд┐рд╢рди",
            description: "рдХреЛрд░реНрдЯ/рдкреНрд░рд╛рдзрд┐рдХрд░рдг рдореЗрдВ рдЬрдорд╛ рдХрд░реЗрдВ",
          },
          { title: "рд╕рдорд╛рдзрд╛рди", description: "рдХрд╛рдиреВрдиреА рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдкреВрд░реНрдг рдХрд░реЗрдВ" },
        ],
      },
      divorce: {
        title: "рддрд▓рд╛рдХ рдХреА рдкреНрд░рдХреНрд░рд┐рдпрд╛",
        steps: [
          {
            title: "рдпрд╛рдЪрд┐рдХрд╛ рджрд╛рдпрд░ рдХрд░реЗрдВ",
            description: "рддрд▓рд╛рдХ рдХреЗ рдХрд╛рдЧрдЬрд╝рд╛рдд рдЬрдорд╛ рдХрд░реЗрдВ",
          },
          { title: "рдкрддрд┐/рдкрддреНрдиреА рдХреЛ рд╕реВрдЪрдирд╛ рджреЗрдВ", description: "рдХрд╛рдиреВрдиреА рдЕрдзрд┐рд╕реВрдЪрдирд╛" },
          {
            title: "рдкреНрд░рддрд┐рдХреНрд░рд┐рдпрд╛ рдЕрд╡рдзрд┐",
            description: "рдкрддрд┐/рдкрддреНрдиреА рдХреА рдкреНрд░рддрд┐рдХреНрд░рд┐рдпрд╛ рдХреА рдкреНрд░рддреАрдХреНрд╖рд╛ рдХрд░реЗрдВ",
          },
          { title: "рдЦреЛрдЬ/рдмрд╛рддрдЪреАрдд", description: "рд╕рдВрдкрддреНрддрд┐ рд╡рд┐рднрд╛рдЬрди рдЪрд░реНрдЪрд╛" },
          { title: "рдЕрдВрддрд┐рдо рдбрд┐рдХреНрд░реА", description: "рдХреЛрд░реНрдЯ рдХреА рдордВрдЬреВрд░реА" },
        ],
      },
      contract: {
        title: "рдЕрдиреБрдмрдВрдз рд╡рд┐рд╡рд╛рдж рдкреНрд░рдХреНрд░рд┐рдпрд╛",
        steps: [
          {
            title: "рдЕрдиреБрдмрдВрдз рд╕рдореАрдХреНрд╖рд╛",
            description: "рд╢рд░реНрддреЛрдВ рдФрд░ рдЙрд▓реНрд▓рдВрдШрди рдХрд╛ рд╡рд┐рд╢реНрд▓реЗрд╖рдг",
          },
          { title: "рдорд╛рдВрдЧ рдкрддреНрд░", description: "рджреВрд╕рд░реЗ рдкрдХреНрд╖ рдХреЛ рдФрдкрдЪрд╛рд░рд┐рдХ рдиреЛрдЯрд┐рд╕" },
          { title: "рдордзреНрдпрд╕реНрдерддрд╛", description: "рд╕рдорд╛рдзрд╛рди рдХрд╛ рдкреНрд░рдпрд╛рд╕" },
          {
            title: "рдореБрдХрджрдореЗрдмрд╛рдЬреА",
            description: "рдЖрд╡рд╢реНрдпрдХ рд╣реЛрдиреЗ рдкрд░ рдореБрдХрджрдорд╛ рджрд╛рдпрд░ рдХрд░реЗрдВ",
          },
          { title: "рдиреНрдпрд╛рдпрд╛рдзреАрд╢/рд╕рдордЭреМрддрд╛", description: "рдЕрдВрддрд┐рдо рд╕рдорд╛рдзрд╛рди" },
        ],
      },
    },
  },
  mr: {
    progress: "рдкреНрд░рдЧрддреА",
    completed: "рдкреВрд░реНрдг",
    helpText:
      "ЁЯТб рдкрд╛рдпрд▒реНрдпрд╛ рдкреВрд░реНрдг рдореНрд╣рдгреВрди рдЪрд┐рдиреНрд╣рд╛рдВрдХрд┐рдд рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдЪреЗрдХрдмреЙрдХреНрд╕рд╡рд░ рдХреНрд▓рд┐рдХ рдХрд░рд╛. рдЕреЕрдирд┐рдореЗрдЯреЗрдб рдбреЙрдЯреНрд╕ рдкреНрд░рд╡рд╛рд╣рд╛рдЪреА рдкреНрд░рдЧрддреА рджрд░реНрд╢рд╡рддрд╛рдд.",
    workflows: {
      general: {
        title: "рд╕рд╛рдорд╛рдиреНрдп рдХрд╛рдпрджреЗрд╢реАрд░ рдкреНрд░рдХреНрд░рд┐рдпрд╛",
        steps: [
          { title: "рдкреНрд░рд╛рд░рдВрднрд┐рдХ рд╕рд▓реНрд▓рд╛рдорд╕рд▓рдд", description: "рд╡рдХреАрд▓рд╛рд╢реА рднреЗрдЯ" },
          {
            title: "рдХреЗрд╕ рдореВрд▓реНрдпрд╛рдВрдХрди",
            description: "рдХрд╛рдпрджреЗрд╢реАрд░ рдкрд░реНрдпрд╛рдпрд╛рдВрдЪреЗ рдореВрд▓реНрдпрд╛рдВрдХрди",
          },
          { title: "рдХрд╛рдЧрджрдкрддреНрд░ рддрдпрд╛рд░реА", description: "рдЖрд╡рд╢реНрдпрдХ рдХрд╛рдЧрджрдкрддреНрд░реЗ рдЧреЛрд│рд╛ рдХрд░рд╛" },
          {
            title: "рдлрд╛рдЗрд▓рд┐рдВрдЧ/рд╕рдмрдорд┐рд╢рди",
            description: "рдиреНрдпрд╛рдпрд╛рд▓рдп/рдкреНрд░рд╛рдзрд┐рдХрд░рдгрд╛рдд рд╕рд╛рджрд░ рдХрд░рд╛",
          },
          { title: "рдирд┐рд░рд╛рдХрд░рдг", description: "рдХрд╛рдпрджреЗрд╢реАрд░ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдкреВрд░реНрдг рдХрд░рд╛" },
        ],
      },
      divorce: {
        title: "рдШрдЯрд╕реНрдлреЛрдЯ рдкреНрд░рдХреНрд░рд┐рдпрд╛",
        steps: [
          {
            title: "рдпрд╛рдЪрд┐рдХрд╛ рджрд╛рдЦрд▓ рдХрд░рд╛",
            description: "рдШрдЯрд╕реНрдлреЛрдЯрд╛рдЪреА рдХрд╛рдЧрджрдкрддреНрд░реЗ рд╕рд╛рджрд░ рдХрд░рд╛",
          },
          { title: "рдЬреЛрдбреАрджрд╛рд░рд╛рд▓рд╛ рд╕реВрдЪрдирд╛ рджреНрдпрд╛", description: "рдХрд╛рдпрджреЗрд╢реАрд░ рдЕрдзрд┐рд╕реВрдЪрдирд╛" },
          {
            title: "рдкреНрд░рддрд┐рд╕рд╛рдж рдХрд╛рд▓рд╛рд╡рдзреА",
            description: "рдЬреЛрдбреАрджрд╛рд░рд╛рдЪреНрдпрд╛ рдкреНрд░рддрд┐рд╕рд╛рджрд╛рдЪреА рдкреНрд░рддреАрдХреНрд╖рд╛",
          },
          { title: "рд╢реЛрдз/рд╡рд╛рдЯрд╛рдШрд╛рдЯреА", description: "рдорд╛рд▓рдорддреНрддрд╛ рд╡рд┐рднрд╛рдЬрди рдЪрд░реНрдЪрд╛" },
          { title: "рдЕрдВрддрд┐рдо рд╣реБрдХреВрдордирд╛рдорд╛", description: "рдиреНрдпрд╛рдпрд╛рд▓рдпрд╛рдЪреА рдордВрдЬреВрд░реА" },
        ],
      },
      contract: {
        title: "рдХрд░рд╛рд░ рд╡рд┐рд╡рд╛рдж рдкреНрд░рдХреНрд░рд┐рдпрд╛",
        steps: [
          {
            title: "рдХрд░рд╛рд░ рдкреБрдирд░рд╛рд╡рд▓реЛрдХрди",
            description: "рдЕрдЯреА рдЖрдгрд┐ рдЙрд▓реНрд▓рдВрдШрдирд╛рдЪреЗ рд╡рд┐рд╢реНрд▓реЗрд╖рдг",
          },
          { title: "рдорд╛рдЧрдгреА рдкрддреНрд░", description: "рджреБрд╕рд▒реНрдпрд╛ рдкрдХреНрд╖рд╛рд▓рд╛ рдФрдкрдЪрд╛рд░рд┐рдХ рдиреЛрдЯреАрд╕" },
          { title: "рдордзреНрдпрд╕реНрдереА", description: "рдирд┐рд░рд╛рдХрд░рдгрд╛рдЪрд╛ рдкреНрд░рдпрддреНрди" },
          { title: "рдЦрдЯрд▓рд╛", description: "рдЖрд╡рд╢реНрдпрдХ рдЕрд╕рд▓реНрдпрд╛рд╕ рдЦрдЯрд▓рд╛ рджрд╛рдЦрд▓ рдХрд░рд╛" },
          { title: "рдиреНрдпрд╛рдпрд╛рдзреАрд╢/рддреЛрдбрдЧрд╛", description: "рдЕрдВрддрд┐рдо рдирд┐рд░рд╛рдХрд░рдг" },
        ],
      },
    },
  },
};

interface WorkflowDiagramProps {
  processType?: string;
}

const nodeTypes = {
  workflow: WorkflowNode,
};

const edgeTypes = {
  animated: AnimatedEdge,
};

export default function WorkflowDiagram({
  processType = "general",
}: WorkflowDiagramProps) {
  const { currentLanguage } = useLanguage();
  const t = translations[currentLanguage];

  // Define different workflow processes with translations
  const workflows = {
    general: {
      title: t.workflows.general.title,
      steps: t.workflows.general.steps.map((step, index) => ({
        id: (index + 1).toString(),
        title: step.title,
        description: step.description,
        position: { x: 50 + index * 150, y: 400 - index * 80 },
      })),
    },
    divorce: {
      title: t.workflows.divorce.title,
      steps: t.workflows.divorce.steps.map((step, index) => ({
        id: (index + 1).toString(),
        title: step.title,
        description: step.description,
        position: { x: 50 + index * 150, y: 400 - index * 80 },
      })),
    },
    contract: {
      title: t.workflows.contract.title,
      steps: t.workflows.contract.steps.map((step, index) => ({
        id: (index + 1).toString(),
        title: step.title,
        description: step.description,
        position: { x: 50 + index * 150, y: 400 - index * 80 },
      })),
    },
  };

  const currentWorkflow =
    workflows[processType as keyof typeof workflows] || workflows.general;

  const [completedSteps, setCompletedSteps] = useState<Set<string>>(new Set());

  const handleStepToggle = useCallback((stepId: string, completed: boolean) => {
    setCompletedSteps((prev) => {
      const newSet = new Set(prev);
      if (completed) {
        newSet.add(stepId);
      } else {
        newSet.delete(stepId);
      }
      return newSet;
    });
  }, []);

  const initialNodes: Node[] = useMemo(
    () =>
      currentWorkflow.steps.map((step, index) => ({
        id: step.id,
        type: "workflow",
        position: step.position,
        data: {
          id: step.id,
          title: step.title,
          description: step.description,
          completed: completedSteps.has(step.id),
          onToggle: handleStepToggle,
          completedText: t.completed,
        },
        sourcePosition: Position.Right,
        targetPosition: Position.Left,
      })),
    [currentWorkflow.steps, completedSteps, handleStepToggle, t.completed]
  );

  const initialEdges: Edge[] = useMemo(
    () =>
      currentWorkflow.steps.slice(0, -1).map((step, index) => ({
        id: `e${step.id}-${currentWorkflow.steps[index + 1].id}`,
        source: step.id,
        target: currentWorkflow.steps[index + 1].id,
        type: "animated",
        animated: true,
        style: { stroke: "#3b82f6", strokeWidth: 2 },
      })),
    [currentWorkflow.steps]
  );

  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);

  // Update workflow when language changes
  React.useEffect(() => {
    const newWorkflow =
      workflows[processType as keyof typeof workflows] || workflows.general;
    const newNodes = newWorkflow.steps.map((step, index) => ({
      id: step.id,
      type: "workflow",
      position: step.position,
      data: {
        id: step.id,
        title: step.title,
        description: step.description,
        completed: completedSteps.has(step.id),
        onToggle: handleStepToggle,
        completedText: t.completed,
      },
      sourcePosition: Position.Right,
      targetPosition: Position.Left,
    }));
    setNodes(newNodes);
  }, [
    currentLanguage,
    processType,
    completedSteps,
    handleStepToggle,
    t.completed,
    setNodes,
  ]);

  // Update nodes when completedSteps or language changes
  React.useEffect(() => {
    setNodes((prevNodes) =>
      prevNodes.map((node) => ({
        ...node,
        data: {
          ...node.data,
          completed: completedSteps.has(node.id),
          completedText: t.completed,
        },
      }))
    );
  }, [completedSteps, setNodes, t.completed]);

  const progressPercentage =
    (completedSteps.size / currentWorkflow.steps.length) * 100;

  return (
    <div className="border-2 border-gray-300 rounded-lg bg-gray-50 p-4 mt-4">
      <div className="mb-4">
        <h3 className="text-lg font-bold text-gray-800">
          {currentWorkflow.title}
        </h3>
        <div className="flex items-center space-x-2 mt-2">
          <div className="text-sm text-gray-600">{t.progress}:</div>
          <div className="flex-1 bg-gray-200 rounded-full h-2">
            <div
              className="bg-blue-500 h-2 rounded-full transition-all duration-300"
              style={{ width: `${progressPercentage}%` }}
            />
          </div>
          <div className="text-sm font-semibold text-gray-700">
            {completedSteps.size}/{currentWorkflow.steps.length}
          </div>
        </div>
      </div>

      <div style={{ height: "500px", width: "100%" }}>
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          nodeTypes={nodeTypes}
          edgeTypes={edgeTypes}
          fitView
          fitViewOptions={{ padding: 0.2 }}
        >
          <Background color="#f3f4f6" gap={20} />
          <Controls />
        </ReactFlow>
      </div>

      <div className="mt-4 text-xs text-gray-500">{t.helpText}</div>
    </div>
  );
}
